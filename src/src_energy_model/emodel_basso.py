import math
from math import sin, cos

# Road Graph G_r = (V_r, A_r) (Set of Intersections and Set of links)
# To calculate the energy cost coefficients associated with the road network, G_r is preprocessed to create the cost
# graph G_c = (V_c, A_c) with V_c = V_r and each arc in A_c is composed of one or more adjacent links from A_r.
# every arc in the cost graph represents its respective cost coefficients.

# Each pair of nodes is onneted by a path P_ij formed by a set of consecutive links in the road graph.
# The customer graph is a complete and directed graph G = (V, A) with V = 0 U C U S, V subset Vc
# The depot is node 0, the set of customer nodes is C and set of harging customers by S

# So:
#   Road Graph is Gr (Graph Road)
#   Cost graph is Gc (Graph Cost)
#   Customer Graph is G

# Longitudinal Dynamics of vehicles (t is time!) [1]
#
# m * a(t) = F_t(t) - (F_g(t) + F_r(t) + F_a(t))
#
# m is the total vehicle mass (urb weight + payload)
# a(t) is the instantaneous acceleration (m/s^2)
# F_t(t) is the force generated by the powertrain/brakes
# F_g(t) is the gravity force on non-horizontal roads
# F_r(t) is rolling friction
# F_a(t) is the aerodynamic force

# The can be defined below
# F_g(t) = Gravitational Force   = m * g * sin * theta(t)
# F_r(t) = Rolling Friction      = m * g * C_r * cos * theta(t)
# F_a(t) = Aerodynamic Force     = 0.5 * C_d * A * p * v * (t)^2
#
# g is 9.81m/s^2
# theta(t) is the instantaneous road inclination angle
# C_r is rolling resistance coefficient
# C_d is the drag coefficient
# A is the frontal surface of the vehicle (m^2)
# P is the air density (kg/m^3)
# V(t) is the instantaneous speed (m/s)

# Mechanical Power Pm(t) needed to make the vehicle move, calculated by multiplying [1] by instantaneous speed. [2]
# Pm(t) = m * a * v(t) + m * g * v(t) * sin * theta(t) + m * g * v(t) * C_r * cos * theta(t) + 0.5 * C_d * A * p * v(t)^3


# mechanical power is
# m * a * v(t) + m * g * v(t) * sin theta(t) + m * g * v(t) * cr * cos * theta(t) + 0.5 * cd * A * p * v(t)^3

cr = 0.0064         # rolling resistance, from basso
cd = 0.7            # air drag , basso
A = 8.0             # vehicle frontal area (in metres squared) , basso
p = 1.2             # air density in kg/m^3
g = 9.81

# m is vehicle mass
# a is instantaneous vehicle acceleration
# v, v(t) is vehicle speed
# theta is road angle (in degrees)

m = 1000
acc = 0.0

def get_mechanical_power(s, ang):
    ang = math.radians(ang)
    return m * acc * s + m * g * s * sin(ang) + m * g * s * cr * cos(ang) + 0.5 * cd * A * p * s**3

print(get_mechanical_power(11.11111, -2.49))

# Energy & Efficiency
# The electric powertrain is composed of several components that convert electric energy from the battery into a mechanical fore
# to make the vehicle move. It is possible to reover energy and charge the battery when the vehicle is braking. The

# We can get instantaneus electric power from mechanical power dependent on if MP is positive/negative
# P_e(t) =  Pm(t) / n_+(t)  IF pm(t) >= 0
#           Pm(t) / n_-(t)  ELSE

# n_+(t) and n_-(t) are the instantaneous efficiency for the complete powertrain. (battery to wheels and wheels to battery)
# Traction Mode N+
# Regeneration Mode N-
# Regen mdoe can be triggered by negative acceleration/road grade

# Total Mechanical Energy e_m needed to drive a certain stretch of road, can becalculated by integrating [2] with time.
# Given an approimated constatn acceleration/deceleration a*, initial speed v_i and total surface distance d(m)
# e_m = (mass * acceleration * distance + mass * gravity * distance * sin * gradient + 0.5 * drag_coefficient * frontal_surface * air_density * distance * (initial_speed^2 + (final_speed^2 - initial_speed^2) / 2)) / 3600






# Acceleration & Speed Curves
#
#   Acceleration Distance = (steady_speed^-2 - initial_speed^2) / 2 * acceleration
#   Deceleration Distance = (final_speed^2 - steady_speed^-2) / 2 * deceleration
#
#
#
#                        acceleration_distance * (mass * acceleration + mass * gravity * sin * ab_gradient + mass * gravity * rolling_resistance * cos * ab_gradient + R * (initial_speed^2 + (steady_speed^-2 - initial_speed^2) / 2)))
# acceleration energy = ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#                                                                                                   3600 * n_accelerate

#                   (distance_ab - distance_acceleration - distance_deceleration) * (mass * gravity * sin * gradient_ab + mass * gravity * rolling_resistane * cos * gradient_ab + R * steady_speed^-2)
# steady_energy = ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#                                                                                                   36000 * n_steady

#                          deceleration_distance * (mass * deceleration + mass *gravity * sin * gradient_ab + mass * gravity * rolling_resistance * cos * gradient_ab + R * (steady_speed^-2 + (final_speed^-2 - steady_speed^-2) / 2))
# deceleration_energy = ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#                                                                                                   36000 * n_deceleration









